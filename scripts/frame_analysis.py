import sys
import open3d as o3d
import matplotlib.pyplot as plt
import numpy as np
# from surfacedetector/utility/line_mesh import LineMesh
from surfacedetector.utility.line_mesh import LineMesh
from scripts.o3d_util import create_grid, create_box, tranform_vectors, rotate_vectors, create_transform, create_point
from surfacedetector.utility.helper_linefitting import compute_turning_manuever

np.set_printoptions(precision=3, suppress=True)

# Flip Y to Z, Z to -Y
MOUNT_TO_SENSOR_ROT = np.linalg.inv(np.array([
    [1, 0, 0],
    [0, 0, -1],
    [0, 1, 0]
]))


def main():
    # Contants you can change
    POI_OFFSET = 0.5
    PLATFORM_WIDTH = 1.16
    PLATFORM_HEIGHT = 0.20
    WHEEL_CHAIR_POS = np.array([-2.5, 1.0, 0])
    WHEEL_CHAIR_ROT = dict(roll=0, pitch=0, yaw=-35)
    SENSOR_MOUNT_POS = np.array([0.34, 0, 0.7])
    SENSOR_MOUNT_ROT = dict(roll=0, pitch=-25, yaw=0)
    SENSOR_POS = np.array([0.0, 0.0, 0.0]) #np.array([0, 0.025, 0.025])

    # Creates origin coordinate frame and grid
    global_frame = o3d.geometry.TriangleMesh.create_coordinate_frame(size=0.2)
    grid = create_grid(size=5, n=20) # each square is 25X25 CM, size is 5X5

    # Defnitions of the Platform Box, Platform Center Point, and Platform Point of Interest (POI) 
    platform = dict(parent=None, center_point=np.array([0, 2, 0]), depth=PLATFORM_HEIGHT, width=PLATFORM_WIDTH, height=1.0, rotation=dict(roll=0, pitch=0, yaw=0))
    platform_cp = dict(parent=platform, center_point=np.array([0, -0.5, 0.125]), size=0.02, rotation=dict(roll=0, pitch=0, yaw=0), color=[1,0,0])
    platform_poi = dict(parent=platform, center_point=np.array([0, -0.5 - POI_OFFSET, 0.125]), size=0.02, rotation=dict(roll=0, pitch=0, yaw=0), color=[0,1,0])

    # wheelchair Box, Sensor Mount, and Sensor
    wheel_chair = dict(parent=None, center_point=WHEEL_CHAIR_POS, depth=0.7, width=0.68, height=0.68, rotation=WHEEL_CHAIR_ROT)
                                            # offset from wheelchair center          rotation from wheelchair frame
    sensor_mount = dict(parent=wheel_chair, center_point=SENSOR_MOUNT_POS, rotation=SENSOR_MOUNT_ROT, width=0.1, depth=0.05, height=0.03)
    sensor = dict(parent=sensor_mount, center_point=SENSOR_POS, rotation=dict(roll=0, pitch=0, yaw=0), post_rot=MOUNT_TO_SENSOR_ROT, width=0.01, depth=0.025, height=0.01)

    # Create Open 3D Geometries, these geometries are defined in the WORLD FRAME, these geometries can then be visualized below
    # You don't need to understand these functions, they just returns a geometry to render
    platform_geom = create_box(platform)
    platform_cp_geom = create_point(platform_cp)
    platform_poi_geom = create_point(platform_poi)
    wheel_chair_geom = create_box(wheel_chair, set_origin_to_front=True)
    sensor_mount_geom = create_box(sensor_mount)
    sensor_geom = create_box(sensor)

    # Get sensor, poi, and wheelchair 3D position and 2D projections in WORLD frame
    sensor_pos_world = sensor['geom'].get_center()
    platform_cp_pos_world = platform_cp['geom'].get_center()
    platform_poi_pos_world = platform_poi['geom'].get_center()[:3]
    wheel_chair_pos_world =  (wheel_chair['transform'] @ np.array([0, 0, 0, 1]))[:3]  # wheel_chair_geom[1].get_center()
    sensor_pos_world_proj = np.copy(sensor_pos_world)
    platform_poi_pos_world_proj = np.copy(platform_poi_pos_world)
    wheel_chair_pos_world_proj = np.copy(wheel_chair_pos_world)
    sensor_pos_world_proj[2] = 0
    platform_poi_pos_world_proj[2] = 0
    wheel_chair_pos_world_proj[2] = 0

    platfrom_normal = o3d.geometry.TriangleMesh.create_arrow(cylinder_radius=0.005, cone_radius=0.01, cylinder_height=0.20, cone_height=0.02).transform(platform_cp['transform'])
    platfrom_normal= platfrom_normal.compute_vertex_normals().paint_uniform_color([1, 0, 0]).rotate(platfrom_normal.get_rotation_matrix_from_xyz([np.pi/2, 0, 0]))
    # Create line between wheelchair center and poi (Blue) and INCORRECT LINE between sensor frame and poi (Purple)
    vec3_geom_1 = LineMesh([sensor_pos_world, platform_poi_pos_world, sensor_pos_world_proj, platform_poi_pos_world_proj ], lines=[[0, 1], [2,3]], radius=0.005, colors=[0.5, 0, 0.5])
    vec3_geom_2 = LineMesh([wheel_chair_pos_world_proj, platform_poi_pos_world_proj], lines=[[0, 1]], radius=0.005, colors=[0, 0, 1])

    # Simulate POI and wall_normal in SENSOR frame, this is what is generated by RealSense Frame
    transform = np.linalg.inv(sensor['transform'])
    platform_cp_pos_sensor = tranform_vectors(platform_cp_pos_world, transform )
    platform_normal_sensor = rotate_vectors([0, -1, 0], transform )
    platform_poi_pos_sensor = tranform_vectors(platform_poi_pos_world, transform )


    # Transform POI3D and Wall Normal into WHEELCHAIR frame, all you need are the constants SENSOR_MOUNT_POS, SENSOR_MOUNT_ROT, SENSOR_POS, MOUNT_TO_SENSOR_ROT
    SENSOR_TO_WHEEL_CHAIR = create_transform(SENSOR_MOUNT_POS, SENSOR_MOUNT_ROT) @ create_transform(SENSOR_POS, MOUNT_TO_SENSOR_ROT)
    platform_cp_pos_wheel_chair = tranform_vectors(platform_cp_pos_sensor, SENSOR_TO_WHEEL_CHAIR)
    platform_normal_wheel_chair = rotate_vectors(platform_normal_sensor, SENSOR_TO_WHEEL_CHAIR)
    # platform_poi_pos_wheel_chair = tranform_vectors(platform_poi_pos_sensor, SENSOR_TO_WHEEL_CHAIR)
    platform_poi_pos_wheel_chair = platform_normal_wheel_chair * POI_OFFSET + platform_cp_pos_wheel_chair # this line will result in the same calculation as above, VERIFIED

    print(f"Platform POI in World Frame: {platform_poi_pos_world}")
    print(f"Platform POI in Sensor Frame: {platform_poi_pos_sensor}")
    print(f"Platform POI in wheelchair Frame: {platform_poi_pos_wheel_chair}")
    print(f"Platform Normal in wheelchair Frame: {platform_normal_wheel_chair}")

    # print(f"Platform Center in Sensor Frame: {platform_cp_pos_sensor}")
    # print(f"Platform Normal in Sensor Frame: {platform_normal_sensor}")


    print("\nCalculated Angles....Creating Turn Procedure")
    result = compute_turning_manuever(platform_cp_pos_wheel_chair, platform_normal_wheel_chair, poi_offset=POI_OFFSET, debug=True)

    plt.draw()
    plt.pause(0.01)

    o3d.visualization.draw_geometries([global_frame, grid, *wheel_chair_geom, *platform_geom, *platform_cp_geom, 
                                        *platform_poi_geom,*sensor_mount_geom, sensor_geom[1], platfrom_normal,
                                        *vec3_geom_1.cylinder_segments, *vec3_geom_2.cylinder_segments])



def arrow_(ax, x, y, dx, dy, **kwargs):
    ax.arrow(x, y, dx, dy, **kwargs)
    ax.scatter(x + dx + 0.1, y + dy + 0.1, alpha=0.0)

if __name__ == "__main__":
    main()



